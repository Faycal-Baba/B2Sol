package Solidity.textGen;

/*Generated by MPS */

import jetbrains.mps.text.rt.TextGenAspectBase;
import Solidity.structure.LanguageConceptSwitch;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.text.rt.TextGenDescriptor;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.text.rt.TextGenModelOutline;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;

public class TextGenAspectDescriptor extends TextGenAspectBase {
  private final LanguageConceptSwitch myIndex = new LanguageConceptSwitch();

  public TextGenAspectDescriptor() {
  }

  @Nullable
  @Override
  public TextGenDescriptor getDescriptor(@NotNull SAbstractConcept concept) {
    switch (myIndex.index(concept)) {
      case LanguageConceptSwitch.AddressCast:
        return new AddressCast_TextGen();
      case LanguageConceptSwitch.ArrayPush:
        return new ArrayPush_TextGen();
      case LanguageConceptSwitch.ArrayType:
        return new ArrayType_TextGen();
      case LanguageConceptSwitch.AssignementStatement:
        return new AssignementStatement_TextGen();
      case LanguageConceptSwitch.BalanceOf:
        return new BalanceOf_TextGen();
      case LanguageConceptSwitch.BinaryExpression:
        return new BinaryExpression_TextGen();
      case LanguageConceptSwitch.BlockComment:
        return new BlockComment_TextGen();
      case LanguageConceptSwitch.Constructor:
        return new Constructor_TextGen();
      case LanguageConceptSwitch.Contract:
        return new Contract_TextGen();
      case LanguageConceptSwitch.DotExpression:
        return new DotExpression_TextGen();
      case LanguageConceptSwitch.EmptyLine:
        return new EmptyLine_TextGen();
      case LanguageConceptSwitch.EmptySstatement:
        return new EmptySstatement_TextGen();
      case LanguageConceptSwitch.EnumDefinition:
        return new EnumDefinition_TextGen();
      case LanguageConceptSwitch.EnumMember:
        return new EnumMember_TextGen();
      case LanguageConceptSwitch.FalseExpression:
        return new FalseExpression_TextGen();
      case LanguageConceptSwitch.FunctionCall:
        return new FunctionCall_TextGen();
      case LanguageConceptSwitch.FunctionDefinition:
        return new FunctionDefinition_TextGen();
      case LanguageConceptSwitch.GreaterThanExpression:
        return new GreaterThanExpression_TextGen();
      case LanguageConceptSwitch.Identifier:
        return new Identifier_TextGen();
      case LanguageConceptSwitch.IfStatement:
        return new IfStatement_TextGen();
      case LanguageConceptSwitch.ImmuableStateVariableDeclaration:
        return new ImmuableStateVariableDeclaration_TextGen();
      case LanguageConceptSwitch.Index:
        return new Index_TextGen();
      case LanguageConceptSwitch.IntegerLiteral:
        return new IntegerLiteral_TextGen();
      case LanguageConceptSwitch.LineComment:
        return new LineComment_TextGen();
      case LanguageConceptSwitch.LocalVarDeclaration:
        return new LocalVarDeclaration_TextGen();
      case LanguageConceptSwitch.Mapping:
        return new Mapping_TextGen();
      case LanguageConceptSwitch.MappingElement:
        return new MappingElement_TextGen();
      case LanguageConceptSwitch.MaxUint:
        return new MaxUint_TextGen();
      case LanguageConceptSwitch.Minusminus:
        return new Minusminus_TextGen();
      case LanguageConceptSwitch.NotExpression:
        return new NotExpression_TextGen();
      case LanguageConceptSwitch.Parameter:
        return new Parameter_TextGen();
      case LanguageConceptSwitch.ParameterList:
        return new ParameterList_TextGen();
      case LanguageConceptSwitch.ParenthesisExpression:
        return new ParenthesisExpression_TextGen();
      case LanguageConceptSwitch.PayableFunctionDefinition:
        return new PayableFunctionDefinition_TextGen();
      case LanguageConceptSwitch.Plusplus:
        return new Plusplus_TextGen();
      case LanguageConceptSwitch.PowerExpression:
        return new PowerExpression_TextGen();
      case LanguageConceptSwitch.RequireStatement:
        return new RequireStatement_TextGen();
      case LanguageConceptSwitch.ReturnStatement:
        return new ReturnStatement_TextGen();
      case LanguageConceptSwitch.SolidityGlobalVariables:
        return new SolidityGlobalVariables_TextGen();
      case LanguageConceptSwitch.StateVariableDeclaration:
        return new StateVariableDeclaration_TextGen();
      case LanguageConceptSwitch.StatementBlock:
        return new StatementBlock_TextGen();
      case LanguageConceptSwitch.StringLiteral:
        return new StringLiteral_TextGen();
      case LanguageConceptSwitch.StructDefinition:
        return new StructDefinition_TextGen();
      case LanguageConceptSwitch.TransferStatement:
        return new TransferStatement_TextGen();
      case LanguageConceptSwitch.TrueExpression:
        return new TrueExpression_TextGen();
      case LanguageConceptSwitch.Type:
        return new Type_TextGen();
      case LanguageConceptSwitch.UserType:
        return new UserType_TextGen();
      case LanguageConceptSwitch.WhileStatement:
        return new WhileStatement_TextGen();
      case LanguageConceptSwitch.revert:
        return new revert_TextGen();
      case LanguageConceptSwitch.structMemberList:
        return new structMemberList_TextGen();
      case LanguageConceptSwitch.varDecExpression:
        return new varDecExpression_TextGen();
    }
    return null;
  }

  @Override
  public void breakdownToUnits(@NotNull TextGenModelOutline outline) {
    for (SNode root : outline.getModel().getRootNodes()) {
      if (root.getConcept().equals(CONCEPTS.Contract$GR)) {
        String fname = getFileName_Contract(root);
        String ext = getFileExtension_Contract(root);
        outline.registerTextUnit((ext == null ? fname : (fname + '.' + ext)), root);
        continue;
      }
    }
  }
  private static String getFileName_Contract(SNode node) {
    return SPropertyOperations.getString(node, PROPS.name$MnvL) + "-contract";
  }
  private static String getFileExtension_Contract(SNode node) {
    return "sol";
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Contract$GR = MetaAdapterFactory.getConcept(0xf72d32028a4541adL, 0xbb612369f7191040L, 0x6d3985c698bd882bL, "Solidity.structure.Contract");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
